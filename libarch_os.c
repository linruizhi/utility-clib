#include "libarch_os.h"

#if UTILITY_SYSTEM_USE_OS
#if UTILITY_SYSTEM_ARCH == 0
/*
*********************************************************************************************************
*	函 数 名: libc_malloc
*	功能说明: 申请内存
*	形    参: size
*	返 回 值: 地址
*********************************************************************************************************
*/
void* libc_malloc( int size )
{
    void* tmp;
	
    tmp = pvPortMalloc( size );
    if ( tmp == NULL)
    {
        DSAFE_PRINT("malloc False\r\n");
    }
    
    return tmp;
}

/*
*********************************************************************************************************
*	函 数 名: libc_malloc
*	功能说明: 申请内存，并初始化为0
*	形    参: size
*	返 回 值: 地址
*********************************************************************************************************
*/
void* libc_calloc( int size )
{
    void* tmp;
	
    tmp = pvPortMalloc( size );
    if ( tmp == NULL)
    {
        DSAFE_PRINT("malloc False\r\n");
    }else{
        memset(tmp, 0, size);
    }
    
    return tmp;
}

/*
*********************************************************************************************************
*	函 数 名: libc_free
*	功能说明: 释放内存
*	形    参: 地址
*	返 回 值: 无
*********************************************************************************************************
*/
void libc_free( void * p )
{
    if ( p == NULL ) {
        DSAFE_PRINT("Free Null False\r\n");
        return;
    }
    
	vPortFree( p );
    p=NULL;
}

/*
*********************************************************************************************************
*	函 数 名: libc_gettick
*	功能说明: 获取系统滴答
*	形    参: 无
*	返 回 值: 滴答时间，单位ms
*********************************************************************************************************
*/
int libc_gettick( void )
{
    return HAL_GetTick();
}

/*
*********************************************************************************************************
*	函 数 名: libcOsDelayms
*	功能说明: 任务延迟，进入阻塞态
*	形    参: 延迟时间
*	返 回 值: 无
*********************************************************************************************************
*/
void libcOsDelayms( int ms )
{
    osDelay( ms );
}

/*
*********************************************************************************************************
*	函 数 名: libcOsMutexNew
*	功能说明: 创建互斥量
*	形    参: 无
*	返 回 值: 互斥量句柄
*********************************************************************************************************
*/
libcOsMutex_t libcOsMutexNew( void )
{
    return xSemaphoreCreateMutex();
}

/*
*********************************************************************************************************
*	函 数 名: libcOsMutexLock
*	功能说明: 互斥量获取，阻塞
*	形    参: 互斥量句柄
*	返 回 值: 操作返回值
*********************************************************************************************************
*/
libcerr libcOsMutexLock( libcOsMutex_t sem )
{
    BaseType_t err = pdFALSE;
    
    if ( sem ) {
        /* 疑问？这里超时是0xFFFF,还需要while吗 */
        do {
            err = xSemaphoreTake( sem, 0xffff );
        } while ( err != pdTRUE );
    }
    
    return LIBC_ERR_OK;
}

/*
*********************************************************************************************************
*	函 数 名: libcOsMutexUnlock
*	功能说明: 互斥量获取
*	形    参: 互斥量句柄
*	返 回 值: 操作返回值
*********************************************************************************************************
*/
libcerr libcOsMutexUnlock( libcOsMutex_t sem )
{
    if ( sem ) {
        xSemaphoreGive( sem );
    }
    
    return LIBC_ERR_OK;
}

/*
*********************************************************************************************************
*	函 数 名: libcOsRecursiveMutexLock
*	功能说明: 互斥量获取，阻塞
*	形    参: 信号量句柄
*	返 回 值: 操作结果
*********************************************************************************************************
*/
libcerr libcOsRecursiveMutexLock( libcOsMutex_t sem )
{
    BaseType_t err = pdFALSE;
    
    do {
        err = xSemaphoreTakeRecursive( sem, 0xffff );
    } while ( err != pdTRUE );
    
    return LIBC_ERR_OK;
}

/*
*********************************************************************************************************
*	函 数 名: libcOsRecursiveMutexUnlock
*	功能说明: 互斥量释放
*	形    参: 信号量句柄
*	返 回 值: 操作结果
*********************************************************************************************************
*/
libcerr libcOsRecursiveMutexUnlock( libcOsMutex_t sem )
{
    xSemaphoreGiveRecursive( sem );
    
    return LIBC_ERR_OK;
}

/*
*********************************************************************************************************
*	函 数 名: libcOsMutexDelete
*	功能说明: 互斥量删除，一般不用
*	形    参: 信号量句柄
*	返 回 值: 无
*********************************************************************************************************
*/
void libcOsMutexDelete( libcOsMutex_t* sem )
{
    vSemaphoreDelete( sem );
}

#endif //UTILITY_SYSTEM_ARCH
#endif //UTILITY_SYSTEM_USE_OS